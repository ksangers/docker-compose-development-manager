#!/usr/bin/env bash
# vim: et:sw=2:ts=2:ai

set -euo pipefail

if [[ "$(id -u)" == "0" ]]; then
  echo "This script should not be run as root."
  exit 1
fi
if [ -e /proc/1/cgroup ] && ! head -n1 /proc/1/sched | grep -qce '\(init\|systemd\)'; then
  echo "This script should not be run from a docker container."
  exit 1
fi

_dev() {
  local cache_dir cache_lc cache_su cache_kl cache_ae cache_ph cache_ne \
    cache_pi env self_bin self_path pwd traefik_path traefik_dc load_env \
    dc machine dc_file
  readonly env=dev
  readonly self_bin="$(realpath "$0")"
  readonly self_path="$(dirname "$self_bin")"
  readonly help_bin="$self_path/help"
  pwd="$(pwd)"
  readonly traefik_path="$self_path/traefik"
  readonly traefik_dc="$traefik_path/docker-compose.yaml"
  PWD="$pwd"
  export PWD
  _auto_update() {
    _load_cache
    touch -d '-16 hours' "$cache_lc"
    [ "$cache_lc" -nt "$cache_pi" ] && touch "$cache_pi" && "$self_bin" pull
    [ "$cache_lc" -nt "$cache_su" ] && touch "$cache_su" && self_update && check
    return 0
  }
  _find_dc_and_try() {
    [ -z "${1:-}" ] && "$help_bin" && exit 0
    _load_dc
    local path="$pwd" r
    while [ "$path" != "/" ]; do
      pwd="$path"
      if _is_dc; then
        cd "$path"
        if [ "$(type -t "${1:-}")" == "function" ]; then
          "$@"
          exit $?
        fi
        "$@" 2>/dev/null
        r=$?
        [ "$r" -gt 0 ] && "$help_bin" "$1"
        exit $r
      fi
      path="$(readlink -f "$path"/..)"
    done
    echo "Error: No docker compose file found"
    return 1
  }
  _in_array() {
    local a v="$1"
    shift
    for a; do [ "$a" == "$v" ] && return 0; done
    return 1
  }
  _is_dc() {
    for dc_file in docker-compose.y{a,}ml; do [ -e "$pwd/$dc_file" ] && dc_file="$pwd/$dc_file" && return 0; done
    return 1
  }
  _load_cache() {
    [ -n "${cache_dir:-}" ] && return 0
    cache_dir="$HOME/.cache/development-manager-docker-compose"
    [ ! -e "$cache_dir" ] && mkdir -p "$cache_dir"
    find "$cache_dir" -type f -mtime +1 -delete
    declare -A caches
    caches[cache_lc]="limit_comparison"
    caches[cache_su]="self_update"
    caches[cache_kl]="known_locations"
    caches[cache_ae]="active_environments"
    caches[cache_ph]="published_hosts"
    caches[cache_ne]="new_environments"
    caches[cache_pi]="project_id_$(echo "$pwd" | base64)"
    for key in "${!caches[@]}"; do
      [ -z "${!key:-}" ] && eval "$key=\"$cache_dir/${caches[$key]}\""
      [ ! -e "${!key}" ] && touch "${!key}" && readonly "$key"
    done
    return 0
  }
  _load_dc() {
    [ -n "${dc:-}" ] && return 0
    _load_machine
    dc="docker-compose --log-level ERROR"
    [ "$machine" == "windows" ] && dc="winpty docker-compose --log-level ERROR"
    readonly dc
    return 0
  }
  _load_dependencies() {
    _load_machine
    if [ "$machine" == "macos" ]; then
      which gtouch >/dev/null && touch() { gtouch "$@"; } && return 0
      echo "Error: Required tools are missing, run: brew install coreutils"
      exit 1
    fi
    return 0
  }
  _load_env() {
    [ -n "${load_env:-}" ] && return 0
    _load_machine
    _load_dependencies
    _load_user
    _load_ssh_sock
    _load_dc
    _load_cache
    _load_vars
    _load_network
    load_env=1
    return 0
  }
  _load_machine() {
    [ -n "${machine:-}" ] && return 0
    case "$(uname -s | tr '[:upper:]' '[:lower:]')" in
    linux*) machine=linux ;;
    darwin*) machine=macos ;;
    mingw*) machine=windows ;;
    *) echo "Error: Unknown machine type" && exit 1 ;;
    esac
    readonly machine
    return 0
  }
  _load_network() {
    [ -n "${HOST_IP:-}" ] && return 0
    _load_machine
    case "$machine" in
    windows | macos) readonly HOST_IP=host.docker.internal ;;
    linux) readonly HOST_IP=$(ip -4 addr show docker0 | grep -Po 'inet \K[\d.]+') ;;
    esac
    export HOST_IP
    if docker network list --format "{{.Name}}" | grep -xcq gateway; then
      docker network create --driver=bridge --attachable --internal=false gateway &>/dev/null
    fi
    return 0
  }
  _load_ssh_sock() {
    if [[ "${SSH_AUTH_SOCK:-}" == "" ]]; then
      readonly SSH_AUTH_SOCK="/tmp/.ssh-sock"
      ssh-agent -a "$SSH_AUTH_SOCK" &>/dev/null
    fi
    export SSH_AUTH_SOCK
    return 0
  }
  _load_user() {
    [ -n "${CHOME:-}" ] && return 0
    _load_machine
    GID="$(id -g)" CUID="$UID" CGID="$GID" CHOME="$HOME"
    [ "$machine" == "windows" ] && CUID="1000" CGID="1000" CHOME="/home/app"
    readonly GID UID CUID CGID CHOME
    export GID UID CUID CGID CHOME
    return 0
  }
  _load_vars() {
    set -a
    # shellcheck source=/dev/null
    for i in .env .env.local .env.$env .env.$env.local; do [ -e "$pwd/$i" ] && source "$pwd/$i"; done
    set +a
    return 0
  }
  _parse_yaml() {
    [ -n "${1:-}" ] && [ -n "${2:-}" ] || return 0
    local prefix="$2"
    local s='[[:space:]]*' w='[a-zA-Z0-9_\-]*' fs
    fs=$(echo @ | tr @ '\034')
    # shellcheck disable=SC1087
    sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
      awk -F"$fs" '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
          vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
          sub(/-/, "_", vn)
          sub(/-/, "_", $2)
          printf("%s%s%s=\"%s\"\n", "'"$prefix"'",vn, $2, $3);
        }
      }' | tr '`' '"' | sed 's/"\([a-z0-9\-\.][a-z0-9\-\.]*\)"/\\"\1\\"/g' |
      sed '/^..*=/{s/-/_/g;}'
  }
  _publish_hosts() {
    # shellcheck disable=SC2001
    while read -r line; do kill "$(/bin/ps -ao pid,cmd | grep -Po "[0-9]+ (?=$(echo "$line" | sed 's/\./\\\./g'))")" 2>/dev/null || true; done <"$cache_ph"
    touch "$cache_ph"
    if [ "$(wc -l <"$cache_ae")" != "0" ]; then
      # shellcheck disable=SC2046
      docker inspect \
        -f '{{if .Config.Labels.dev_domain}}{{.Config.Labels.dev_domain}} {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}{{end}}' \
        $(docker ps -aq) |
        grep -E '^[a-z0-9\-\.]+ [0-9\.]+$' |
        xargs --max-lines=1 --no-run-if-empty echo "avahi-publish -a $line" >>"$cache_ph"
      # shellcheck source=/dev/null
      [ -e "$cache_ph" ] && source "$cache_ph"
    fi
    return 0
  }
  _start_traefik() {
    _load_cache
    _load_dc
    if ! grep -qxF "$traefik_path" "$cache_ae"; then
      $dc -f "$traefik_dc" up -d
      echo "$traefik_path" >>"$cache_ae"
    fi
    return
  }
  _stop_traefik() {
    _load_cache
    _load_dc
    if grep -qxF "$traefik_path" "$cache_ae"; then
      $dc -f "$traefik_dc" down
      grep -xFv "$traefik_path" "$cache_ae" >"$cache_ne" || touch "$cache_ne"
      cp "$cache_ne" "$cache_ae"
    fi
    return
  }
  attach() {
    _load_dc
    $dc up "${1:-}" && return
    help attach
    return 1
  }
  check() {
    _is_dc || _find_dc_and_try check || return 1
    _load_vars;_load_user;_load_network
    eval "$(_parse_yaml "$dc_file" "dc_")"
    [ -z "${dc_x_custom_type:-}" ] && return 0
    for dc_latest in "$self_path/templates/$dc_x_custom_type"/docker-compose.y{a,}ml; do [ -e "$dc_latest" ] && break; done
    if [ -n "$dc_x_custom_type" ] && [ -e "$dc_latest" ]; then
      eval "$(_parse_yaml "$dc_latest" "dcl_")" &>/dev/null
      if [ -n "$dc_x_custom_version" ] || [ -n "$dcl_x_custom_version" ] && [ "$dcl_x_custom_version" != "$dc_x_custom_version" ]; then
        echo "The current docker template is outdated, run \"$(basename "$self_bin") init $dc_x_custom_type -f\" to update it."
        return 1
      fi
      for i; do [ "$i" == "-v" ] && echo "The current docker template is up-to-date."; done
    fi
    return 0
  }
  dc() {
    _load_dc
    _is_dc && $dc "$@"
    ! _is_dc && _find_dc_and_try dc "$@"
    return
  }
  # shellcheck disable=SC2120
  down() {
    _load_dc
    _load_cache
    if _in_array "-a" "$@"; then
      while read -r pwd; do cd "$pwd" && _is_dc && "$self_bin" down; done <"$cache_kl"
      exit 0
    elif _is_dc; then
      $dc down "$@"
      grep -xFv "$pwd" "$cache_ae" >"$cache_ne" || true
      cp "$cache_ne" "$cache_ae"
      grep -xFvcq "$traefik_path" "$cache_ae" || _stop_traefik
      _publish_hosts
      return 0
    fi
    _find_dc_and_try down "$@" && return 0
    help down
    return 1
  }
  help() {
    "$help_bin" "$@"
    return 0
  }
  # shellcheck disable=SC2120
  init() {
    local type=""
    for type; do if [ -e "$self_path/templates/$type" ]; then break; else type=""; fi; done
    [ "$type" == "" ] && echo "Error: No valid type supplied" && "$help_bin" init && exit 1
    _is_dc && ! _in_array "-f" "$@" && ! _in_array "--force" "$@" && echo "Warning: Project already initialized. Use --force to re-initialize the project" && exit 1
    cp -prf "$self_path"/templates/"$type"/{,.[!.]}* "$pwd"
    return
  }
  ps() {
    _load_cache
    if _in_array "-a" "$@"; then
      while read -r pwd; do cd "$pwd" && _is_dc && echo && echo -e '\E[32m'"\033[1m$pwd \033[0m" && "$self_bin" ps; done <"$cache_kl"
      exit $?
    fi
    _is_dc && "$self_bin" dc ps "$@" && return
    _find_dc_and_try dc ps "$@" && return
    return 1
  }
  restart() {
    "$self_bin" down "$@" && "$self_bin" up "$@"
    return
  }
  self_update() {
    cd "$self_path" >/dev/null
    git pull --quiet origin "$(git branch --show-current)"
    chmod +x "$(basename "$(realpath "$0")")"
    return
  }
  up() {
    _auto_update
    ! _is_dc && _find_dc_and_try up "$@" && return 1
    grep -Eq "[^#]*traefik" "$dc_file" && _start_traefik
    grep -qxF "$pwd" "$cache_kl" &>/dev/null || echo "$pwd" >>"$cache_kl"
    $dc up -d "$@"
    grep -qxF "$pwd" "$cache_ae" &>/dev/null || echo "$pwd" >>"$cache_ae"
    ! grep -q "dev_domain=" "$dc_file" || _publish_hosts
    return
  }
  local dc_proxy=(build exec logs pull run)
  readonly dc_proxy
  if _in_array "${1:-}" "${dc_proxy[@]}"; then dc "$@" && return; "$help_bin" "$1" && exit 1; fi
  if [ -n "${1:-}" ]; then "$@"; else "$help_bin"; fi
  exit $?
}
_dev "$@"; exit $?
