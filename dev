#!/usr/bin/env bash
# vim: et:sw=2:ts=2:ai

set -e

if [[ "$(id -u)" == "0" ]]; then
  echo "This script should not be run as root."
  exit 1
fi
if [ -e /proc/1/cgroup ] && ! head -n1 /proc/1/sched | grep -qce '\(init\|systemd\)'; then
  echo "This script should not be run from a docker container." && exit 1
fi

run() {
  attach() {
    $DC up "$1"
    return
  }
  auto_update() {
    touch -d '-16 hours' "$cache_lc"
    # shellcheck disable=SC2119
    if [ "$cache_lc" -nt "$cache_pi" ]; then
      touch "$cache_pi"
      pull
    fi
    if [ "$cache_lc" -nt "$cache_su" ]; then
      touch "$cache_su"
      self_update
      check
    fi
    return
  }
  build() {
    $DC build
    return
  }
  # shellcheck disable=SC2120
  check() {
    for dc_file in docker-compose.y{a,}ml; do test -e "$dc_file" && break; done
    eval "$(parse_yaml "$dc_file" "dc_")"
    for dc_latest in "$self_path/templates/$dc_x_custom_type"/docker-compose.y{a,}ml; do test -e "$dc_latest"] && break; done
    if [ -n "$dc_x_custom_type" ] && [ -e "$dc_latest" ]; then
      eval "$(parse_yaml "$dc_latest" "dcl_")" &>/dev/null
      if [ -n "$dc_x_custom_version" ] || [ -n "$dcl_x_custom_version" ] && [ "$dcl_x_custom_version" != "$dc_x_custom_version" ]; then
        echo "The current docker template is outdated, run \"dev init $dc_x_custom_type -f\" to update it." && return 1
      else
        echo "The current docker template is up-to-date." && return 0
      fi
    elif [ "$1" == "-v" ]; then
      echo "The current docker template is outdated, run \"dev init PROJECT_TYPE -f\" to update it."
      echo "Available project types: "
      for type in "$self_path"/templates/*; do echo "- $(basename "$type")"; done
      return 1
    fi
    return 0
  }
  dc() {
    $DC "$@"
    return $?
  }
  # shellcheck disable=SC2120
  down() {
    if [ "$1" == "-a" ]; then
      while read -r i; do for dc_file in docker-compose.y{a,}ml; do
        if [ -e "$i/$dc_file" ]; then
          cd "$i"
          $self_bin down
          break
        fi
      done; done <"$cache_kl"
    else
      for dc_file in docker-compose.y{a,}ml; do if [ -e "$dc_file" ]; then
        $DC down "$@"
        grep -xFv "$pwd" "$cache_ae" >"$cache_ne"
        cp "$cache_ne" "$cache_ae"
        grep -xFvc "$traefik_path" "$cache_ae" || stop_traefik
        break
      fi; done
    fi
    publish_hosts
    return $?
  }
  exec() {
    restore
    $DC exec "$@"
    return $?
  }
  # shellcheck disable=SC2120
  init() {
    local force=0
    local type=""
    for option in "$@"; do case "$option" in
      -f | --force) force=1 ;;
      *) if [ "$type" == "" ]; then type="$option"; fi ;;
      esac done
    if [ "$type" == "" ]; then
      echo "Error: Type not given"
      help init
      exit 1
    fi
    if [ ! -e "$self_path"/templates/"$type" ]; then
      echo "Error: Type '$type' not found."
      exit 1
    fi
    if [ ! -e "$pwd/docker-compose.yml" ] && [ ! -e "$pwd/docker-compose.yaml" ] || [ "$force" == "1" ]; then
      cp -prf "$self_path"/templates/"$type"/{,.[!.]}* "$pwd"
      return
    elif [ -e "$pwd/docker-compose.yml" ] || [ -e "$pwd/docker-compose.yaml" ]; then
      echo "Warning: Project already initialized. Use --force to re-initialize the project"
      return 1
    fi
    run help init
    return 1
  }
  load_env() {
    case "$(uname -s | tr '[:upper:]' '[:lower:]')" in
    linux*) readonly local machine=linux ;;
    darwin*) readonly local machine=macos ;;
    mingw*) readonly local machine=windows ;;
    esac
    if [[ "$machine" == "macos" ]]; then
      if which gtouch >/dev/null; then touch() { gtouch "$@"; }; fi
      echo "Error: Required tools are missing, run: brew install coreutils"
      return 1
    fi
    export readonly env=dev
    case "$machine" in
    windows | macos) readonly HOST_IP=host.docker.internal ;;
    linux) readonly HOST_IP=$(ip -4 addr show docker0 | grep -Po 'inet \K[\d.]+') ;;
    *)
      echo "Error: Unknown machine type"
      exit 1
      ;;
    esac
    export HOST_IP
    if [[ "$SSH_AUTH_SOCK" == "" ]]; then
      SSH_AUTH_SOCK="/tmp/.ssh-sock"
      ssh-agent -a "$SSH_AUTH_SOCK" &>/dev/null
    fi
    export SSH_AUTH_SOCK
    readonly UID
    readonly GID=$(id -g)
    export GID
    export UID
    if [[ "$machine" == "windows" ]]; then
      readonly DC="winpty docker-compose --log-level ERROR"
      readonly CUID="1000"
      readonly CGID="1000"
      readonly CHOME="/home/app"
    else
      readonly DC="docker-compose --log-level ERROR"
      readonly CUID="$UID"
      readonly CGID="$GID"
      readonly CHOME="$HOME"
    fi
    export CUID
    export CGID
    export CHOME
    readonly local self_bin="$(realpath "$0")"
    readonly local self_path="$(dirname "$self_bin")"
    readonly local traefik_path="$self_path/traefik"
    readonly local traefik_dc="$traefik_path/docker-compose.yaml"
    readonly local pwd="$(pwd)"
    readonly local cache_dir="$HOME/.cache/development-manager-docker-compose"
    readonly local cache_lc="$cache_dir/limit_comparison"
    readonly local cache_pi="$cache_dir/project_id_$(echo "$pwd" | base64)"
    readonly local cache_su="$cache_dir/self_update"
    readonly local cache_kl="$cache_dir/known_locations"
    readonly local cache_ae="$cache_dir/active_environments"
    readonly local cache_ph="$cache_dir/published_hosts"
    readonly local cache_ne="$cache_dir/new_environments"
    readonly local cache_rl="$cache_dir/rediscover_known_locations"
    # shellcheck disable=SC2034
    readonly local cache_ra="$cache_dir/rediscover_active_environments"
    source "$self_path/help"
    test -e "$cache_dir" && mkdir -p "$cache_dir"
    for i in "$cache_lc" "$cache_pi" "$cache_su" "$cache_kl" "$cache_ae" "$cache_ph" "$cache_ne" "$cache_rl" "$cache_ra"; do
      if [ ! -e "$i" ]; then touch "$i"; fi
    done
    find "$cache_dir" -type f -mtime +1 -delete
    set -a
  # shellcheck disable=SC1090
    for i in .env{,."$env"}{,.local}; do test -e "$1/$i" && source "$1/$i"; done
    set +a
    if docker network list --format "{{.Name}}" | grep -xcq gateway; then
      docker network create --driver=bridge --attachable --internal=false gateway &>/dev/null
    fi
    return 0
 }
  logs() {
    $DC logs "$@"
    return
  }
  parse_yaml() {
    local prefix="$2"
    local s='[[:space:]]*'
    local w='[a-zA-Z0-9_\-]*'
    # shellcheck disable=SC2155
    local fs="$(echo @ | tr @ '\034')"
    # shellcheck disable=SC1087
    # shellcheck disable=SC2086
    sed -ne "s|^\($s\):|\1|" \
      -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
      -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" $1 |
      awk -F"$fs" '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
        vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
        sub(/-/, "_", vn)
        sub(/-/, "_", $2)
        printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
      }
    }'
  }
  ps() {
    if [ "$1" == "-a" ]; then
      while read -r i; do for dc_file in docker-compose.y{a,}ml; do
        if [ -e "$i/$dc_file" ]; then
          cd "$i"
          $self_bin ps
          break
        fi
      done; done <"$cache_kl"
    else
      for dc_file in docker-compose.y{a,}ml; do test -e "$dc_file" && $DC ps "$@" && break; done
    fi
    return
  }
  publish_hosts() {
    while read -r line; do
      # shellcheck disable=SC2001
      kill "$(/bin/ps -ao pid,cmd | grep -Po "[0-9]+ (?=$(echo "$line" | sed 's/\./\\\./g'))")" 2>/dev/null
    done <"$cache_ph"
    touch "$cache_ph"
    if [ "$(wc -l <"$cache_ae")" != "0" ]; then
      docker inspect \
        -f '{{if .Config.Labels.dev_domain}}{{.Config.Labels.dev_domain}} {{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}{{end}}' \
        "$(docker ps -aq)" |
        grep -E '^[a-z0-9\-\.]+ [0-9\.]+$' |
        xargs --max-lines=1 echo "avahi-publish -a $line" >>"$cache_ph"
      # shellcheck disable=SC1090
      test -e "$cache_ph" && source "$cache_ph" 2>/dev/null
    fi
    return
  }
  # shellcheck disable=SC2120
  pull() { $DC pull "$@" && return; }
  run() { $DC run "$@" && return; }
  rediscover() {
    while read -r i; do for dc_file in docker-compose.y{a,}ml; do
      if [ -e "$i/$dc_file" ]; then
        echo "$i" >>"$cache_rl"
        echo "$i" >>"$cache_ra"
        break
      fi
    done; done <"$cache_kl"
    cp "$cache_rl" "$cache_kl"
    cp "$cache_ra" "$cache_ae"
    touch "$cache_rl"
    touch "$cache_ra"
    return
  }
  # shellcheck disable=SC2119
  restart() {
    down
    up
    return
  }
  restore() {
    rediscover
    while read -r i; do
      cd "$i" || exit
      top_output="$($self_bin dc -f "$i/docker-compose.yml" top)"
      if [[ $top_output == '' ]]; then $self_bin up; fi
    done <"$cache_ae"
    return
  }
  self_update() {
    cd "$self_path" >/dev/null
    git pull origin "$(git branch --show-current)" &>/dev/null
    chmod +x "$self_bin"
  }
  start_traefik() { test ! grep -qxF "$traefik_path" "$cache_ae" && $DC -f "$traefik_dc" up -d && echo "$traefik_path" >>"$cache_ae"; }
  stop_traefik() {
    if grep -qxF "$traefik_path" "$cache_ae"; then
      $DC -f "$traefik_dc" down
      grep -xFv "$traefik_path" "$cache_ae" >"$cache_ne"
      cp "$cache_ne" "$cache_ae"
    fi
  }
  # shellcheck disable=SC2120
  up() {
    auto_update
    restore
    for dc_file in docker-compose.y{a,}ml; do test -e "$dc_file" && break; done
    grep -Eq "[^#]*traefik" "$dc_file" && start_traefik
    grep -qxF "$pwd" "$cache_kl" &>/dev/null || pwd >>"$cache_kl"
    $DC up -d "$@"
    grep -qxF "$pwd" "$cache_ae" &>/dev/null || pwd >>"$cache_ae"
    grep -q "dev_domain=" "$dc_file" && publish_hosts
    return
  }
  if [ "$(type -t "$1")" == "function" ]; then
    if [ "$1" == "init" ] || load_env; then "$@"; fi
    return
  elif [ "$1" == "help" ]; then
    help "$@"
    return 0
  else
    source "$(dirname "$(realpath "$0")")/help"
    help "$@"
    return 1
  fi
}
run "$@"
exit $?
